import { UsersService } from '../users/users.service';
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DeleteResult, In, Repository, UpdateResult } from 'typeorm';
import { Notification } from './entities/notification.entity';
import { filterNullsObject } from 'src/utils/helpers/filterNulls';
import { User } from '../users/entities/user.entity';
import { CustomResponseType } from 'src/types/custom-response.type';
import { GetAllProps } from 'src/types/get-operators.type';
import { AppService } from 'src/app.service';
import { CreateNotificationDto } from './dto/create-notification.dto';
import { UpdateNotificationDto } from './dto/update-notification.dto';
import { NotificationFields } from 'src/enums/shared/tables-fields.enum';
import { crudResponse } from 'src/responses/crud.response';

@Injectable()
export class NotificationsService {
  constructor(
    @InjectRepository(Notification)
    private readonly notificationRepository: Repository<Notification>,
    private readonly usersService: UsersService,
    private readonly appService: AppService,
  ) {}

  async getNotifications({
    sortBy = NotificationFields.CONTENT,
    reverse = false,
    page = 1,
    conditions,
  }: GetAllProps<NotificationFields>): Promise<
    CustomResponseType<Notification[]>
  > {
    try {
      const findQuery = this.appService.filteredGetQuery({
        sortBy,
        reverse,
        page,
        conditions,
      });

      if (findQuery.status !== 200) {
        return crudResponse.notFoundRes(findQuery.message);
      }

      const response = await this.notificationRepository.find(findQuery.data);

      return crudResponse.foundRes(
        response.length
          ? 'Notifications have been found'
          : 'Notifications list is empty',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async getNotificationById(
    id: string,
  ): Promise<CustomResponseType<Notification>> {
    try {
      const response = await this.notificationRepository.findOneBy({ id });

      if (response) {
        return crudResponse.notFoundRes('Notification does not exist');
      }

      return crudResponse.foundRes('Notification has been found', response);
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async getNotificationsByUserId(
    userId: string,
  ): Promise<CustomResponseType<Notification[]>> {
    try {
      const user = await this.usersService.getUserById(userId);
      if (user.status !== 200) {
        return crudResponse.notFoundRes('User does not exist');
      }

      const response = await this.notificationRepository.find({
        where: { user: { id: In([userId]) } },
        order: { content: 'ASC' },
      });

      return crudResponse.foundRes(
        response.length
          ? 'Notifications have been found'
          : 'Notifications list is empty',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async createNotification(
    createNotificationDto: CreateNotificationDto,
  ): Promise<CustomResponseType<Notification>> {
    try {
      const user = await this.usersService.getUserById(
        createNotificationDto.user,
      );
      if (user.status !== 200) {
        return crudResponse.notFoundRes('User does not exist');
      }

      const newNotification = this.notificationRepository.create({
        user: user.data,
      });

      const response = await this.notificationRepository.save(newNotification);

      return crudResponse.createUpdateRes<Notification>(
        'Notification has been created successfully',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async updateNotification(
    id: string,
    updateNotificationDto: UpdateNotificationDto,
  ): Promise<CustomResponseType<UpdateResult>> {
    try {
      const notification = await this.getNotificationById(id);
      const user = await this.usersService.getUserById(
        updateNotificationDto.user,
      );

      if (!notification || !user) {
        return crudResponse.notFoundRes(
          `${!notification ? 'Notification' : 'User'} does not exist`,
        );
      }

      const response = await this.notificationRepository.update(
        {
          id,
        },
        {
          user: user.data as User,
          ...filterNullsObject(updateNotificationDto),
        },
      );

      return crudResponse.createUpdateRes<UpdateResult>(
        'Notification has been updated successfully',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async toggleIsRead(id: string): Promise<CustomResponseType<UpdateResult>> {
    try {
      const notification = await this.getNotificationById(id);

      if (notification.status !== 200) {
        return crudResponse.notFoundRes('Notification does not exist');
      }

      const response = await this.notificationRepository.update(
        {
          id,
        },
        {
          isRead: !notification.data.isRead,
        },
      );

      return crudResponse.createUpdateRes<UpdateResult>(
        `Notification has been marked as ${
          notification.data.isRead ? 'not read' : 'read'
        }`,
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async deleteAllNotifications(): Promise<CustomResponseType<DeleteResult>> {
    try {
      const response = await this.notificationRepository.query(
        `TRUNCATE TABLE "notification" CASCADE;`,
      );

      return crudResponse.deletedRes(
        'Notifications data are wiped out',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }

  async deleteNotification(
    id: string,
  ): Promise<CustomResponseType<DeleteResult>> {
    try {
      const response = await this.notificationRepository.delete(id);

      if (!response) {
        return crudResponse.notFoundRes('Notification does not exist');
      }

      return crudResponse.deletedRes(
        'Notification has been deleted successfully',
        response,
      );
    } catch (error) {
      return crudResponse.error(error);
    }
  }
}